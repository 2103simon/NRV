Scientific foundations
======================

NRV has been designed as a layer of abstraction of physical, mathematical, and computational techniques required for realistic prediction of bioelectronic phenomena prediction and study. The framework can be used with few lines of Python code on various computing supports, from conventional machines to large super-computer without impacting the simulation descriptions. This framework has also been designed to be linked to optimization algorithms and experimental setups, to ease the translation between novel stimulation protocol development and experimental campaigns.

Framework overview
-------------------
NRV is a fully open-source multi-scale and multi-domain Python-based framework developed for the hybrid modeling of electrical stimulation in the PNS. NRV shares the same working principle as the frameworks presented in the previous section: a FEM model is solved under the quasi-static assumption to compute the extracellular potential generated by a source and is applied to a neural target. However, NRV improves the previous frameworks with its capability of performing all the required steps for hybrid modeling within the framework. Realistic geometries for the electrodes, nerves, and fascicles are constructed using Gmsh (Geuzaine and Remacle 2009), and FEM problems are solved using FEniCS (Aln√¶s et al. 2015). This workflow is fully open-source and requires no software purchase from the end user. A bridge between COMSOL Multiphysics and NRV via COMSOL Server (requiring a commercial license) is also implemented in NRV providing multiple options to the users. Tools for generating realistic axon population and placement are provided and commonly used in the literature axon models are implemented.

Extracellular potential computed with the FEM model is interpolated and used as input for the 1-D axon models. An intracellular voltage or current clamp can also be used to stimulate one or multiple axons of the NRV model. Axons are then simulated using the NEURON framework with the NEURON to Python bridge. All computation inputs and outputs are stored in dictionary objects to enable context saving. Post-processing tools are also provided to automatically detect spikes, filter the data, etc. Extracellular recorders are also implemented and can be added to the model to simulate electrically-evoked compound action potentials (eCAPs).

Large-scale fascicle or nerve simulations are embarrassingly parallel problems and can greatly reduce computation time. NRV also provides multiprocessing capabilities by implementing a message-passing interface (MPI) for Python (Dalcin and Fang 2021). Parallel computing is performed independently from the simulation description and the end-user only needs to provide the maximum number of usable cores on the machine, NRV automatically handles job distribution and synchronicity between the processes. Calls to Gmsh, FenicsX, COMSOL Server, NEURON, or other third-party libraries used are fully encapsulated in the NRV framework making their use completely transparent to the user.

NRV aims at being accessible for users with basic Python knowledge as well as easily readable from high-level simulation perspectives. NRV also enables multi-scale simulations: single axonal fibers to whole nerve simulations can be performed with NRV and require only a couple of lines of code. The framework is pip- or conda installable (python packet managers) making the framework effortlessly deployable on a computer cluster or supercomputer.

NRV‚Äôs internal architecture is depicted in Fig. II.36. It is subdivided into four main sections:
    * **fmod:** for extracellular models and computations. Details of this section are described in section ???
    * **nmod:** for axon membrane potential models and computation. Details of this section is described in section ???
    * **optim:** enables automated optimization of stimulation contexts, either by controlling geometrical parameters or the stimulation waveshape.
    * **backend:** handles all related software engineering aspects behind NRV, such as machine capacity and performances, parallel processing, or file inputs and outputs for instance. This section is essential for the proper functioning of the framework, but mainly concerns the architecture and development of software whose knowledge does not provide relevant information to the end user. Thus, this section is not described in more detail.

Computation of extracellular potentials
---------------------------------------
NRV provides classes, tools, and templates to create 3-D models of the nerve and electrodes. By default, all axons are colinear to the ùë• ‚àí ùëéùë•ùëñùë† of the space frame. Fig. II.37 provides a synthetic overview of the extracellular simulated problem and a simplified UML- class diagram of the software implementation, containing class references that the end-user can access. Here are provided details about the implementation of physics and corresponding computational mechanisms.

The computation of the extracellular electric potential associated with electrical stimulation is handled by the extracellular_context-class. The analytical_stimulation-class and the FEM_stimulation-class are derived from the parent extracellular_context-class as illustrated in Fig. II.37 and detailed in the next two subsections. NRV provides the possibility of analytically estimate compound action potential (CAP) using recorder-objects. 

Electrical stimulation potential: computation mechanism
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

NRV provides classes, tools, and templates to create 3-D models of the nerve and electrodes. By default, all axons are colinear to the ùë• ‚àí ùëéùë•ùëñùë† of the space frame. Fig. II.37 provides a synthetic overview of the extracellular simulated problem and a simplified UML- class diagram of the software implementation, containing class references that the end-user can access. Here are provided details about the implementation of physics and corresponding computational mechanisms.

.. math::
   V_{ext}{\left( \mathbf{r}, t\right)} =  \sum_{k\in E}{I_{stim_k}\left(t\right)V_{footprint_k}\left(\mathbf{r}\right) }